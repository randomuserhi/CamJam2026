import sqlite3 from "better-sqlite3";
import Path from "path";
import VfsPath from "vfs/lib/path.asl";

export type VfsErrorCode = 
    | "PathNotFound"
    | "FileNotFound"
    | "DirectoryNotFound"
    | "TraversalError"
    | "InvalidOperation"
    ;

export class VfsError extends Error {
    public readonly code: VfsErrorCode;

    constructor(code: VfsErrorCode, message: string) {
        super(message);
        this.code = code;
    }
}

export type VfsPermissions = "ReadOnly" | "WriteOnly" | "ReadWrite";

export type VfsNodeType = "file" | "directory";

export interface VfsNode {
    id: number;
    parent_id: number | null;
    type: VfsNodeType;
    name: string;
    size: number | null;
    mtime: number | null;
}

/**
 * Provides basic operations to modify the sqlite3 database
 * backing a virtual drive. This acts as the drives local file system.
 * 
 * Does not manage any operations on the physical drive.
 * 
 * Vfs aggregates all drive DBs to abstract away the individual drive
 * interfaces as well perfroming the actual operations on disk.
 */
export class DriveFileSystem {
    static readonly VALID_COLUMN_NAMES = ["type", "mtime", "size", "name"] as const;
    static readonly VALID_ORDER = ["ASC", "DESC"] as const;

    public static readonly ROOT_NODE_ID = 1;
    public static readonly ROOT_NODE: VfsNode = { 
        id: DriveFileSystem.ROOT_NODE_ID,
        type: "directory",
        name: "ROOT",
        parent_id: null,
        size: null,
        mtime: null
    };

    readonly db: sqlite3.Database;

    /**
     * Gets a file node by id.
     * Returns undefined if it does not exist.
     */
    get: (id: number) => VfsNode | undefined;

    /**
     * Finds a child node by name.
     * Returns undefined if it does not exist.
     */
    findChild: (parentId: number, childName: string) => VfsNode | undefined;

    
    /**
     * Gets the number of children a given node has 
     */
    public childCount(id: number): number {
        return this._childCount(id)!.count;
    }
    private _childCount: (id: number) => { count: number } | undefined;

    /**
     * Lists direct children of a given node
     */
    list: (id: number) => VfsNode[];

    /**
     * Lists direct children of a given node with limit and offset
     */
    limitList: (id: number, limit: number, offset: number) => VfsNode[];

    /**
     * Insert a new node
     */
    insert: (name: string, type: VfsNodeType, parentId: number, mtime: number | null, size: number | null) => VfsNode;

    /**
     * Delete a node
     */
    delete: (id: number) => void;

    /**
     * Move and rename a node
     */
    moveAndRename: (name: string, parentId: number, mtime: number | null, id: number) => void;
    private _moveAndRename: (name: string, parentId: number, mtime: number | null, id: number) => void;

    /**
     * Set a nodes mtime
     */
    setMtime: (mtime: number | null, id: number) => void;

    /**
     * Set a nodes size
     */
    setSize: (size: number | null, id: number) => void;

    /**
     * Set a nodes metadata
     */
    setMeta: (mtime: number | null, size: number | null, id: number) => void;

    /**
     * Returns true if a node is a descendant of another
     */
    public isDescendant(parentId: number, id: number) {
        return this._isDescendant(parentId, id) !== undefined;
    }
    private _isDescendant: (targetParentId: number, nodeId: number) => unknown | undefined;

    /**
     * Returns all nodes under a parent recursively
     */
    tree: (parentId: number) => VfsNode[];

    /**
     * Deletes all children under a parent recursively
     */
    deleteChildren: (parentId: number) => void;

    /**
     * Inserts a sub tree of nodes (generated by `tree(...)` function)
     */
    insertTree: (destId: number, root: VfsNode, tree: VfsNode[], mtime: number | null) => void;

    /**
     * Resolves a string path to a node.
     * Returns undefined if the path does not exist.
     */
    resolve: (path: string) => VfsNode | undefined;

    private prepare(method: "get" | "run" | "all", source: string): any {
        const statement = this.db.prepare(source);
        return statement[method].bind(statement);
    }

    constructor(dbPath: string) {
        this.db = new sqlite3(dbPath);
        this.db.pragma('journal_mode = WAL');
        this.db.pragma('synchronous = NORMAL');
        this.db.pragma('foreign_keys = ON');

        this.db.exec(`
            CREATE TABLE IF NOT EXISTS nodes (
                id          INTEGER PRIMARY KEY,
                name        TEXT NOT NULL,
                type        TEXT NOT NULL CHECK (type IN ('file', 'directory')),
                parent_id   INTEGER REFERENCES nodes(id) ON DELETE CASCADE,
                mtime       INTEGER,
                size        INTEGER,
                UNIQUE (parent_id, name)
            );

            CREATE INDEX IF NOT EXISTS idx_nodes_parent ON nodes(parent_id);
            CREATE INDEX IF NOT EXISTS idx_nodes_type ON nodes(type);
            `);

        // Ensure root exists
        const root = this.db
            .prepare(`SELECT id FROM nodes WHERE parent_id IS NULL`)
            .get();

        if (!root) {
            this.db.prepare(`
                INSERT INTO nodes (id, name, type, parent_id)
                VALUES (${DriveFileSystem.ROOT_NODE_ID}, '/', 'directory', NULL)
            `).run();
        }

        this.get = this.prepare("get", `
            SELECT * FROM nodes WHERE id = ?
            `);

        this.findChild = this.prepare("get", `
            SELECT * FROM nodes WHERE parent_id = ? AND name = ?
            `);

        this._childCount = this.prepare("get", `
            SELECT COUNT(*) AS count FROM nodes WHERE parent_id = ?
            `);

        this.list = this.prepare("all", `
            SELECT * FROM nodes WHERE parent_id = ? ORDER BY type ASC, name
            `);

        this.limitList = this.prepare("all", `
            SELECT * FROM nodes WHERE parent_id = ? ORDER BY type ASC, name LIMIT ? OFFSET ?
            `);

        this.insert = this.prepare("get", `
            INSERT INTO nodes (name, type, parent_id, mtime, size)
            VALUES (?, ?, ?, ?, ?)
            RETURNING *
            `);

        this.delete = this.prepare("run", `
            DELETE FROM nodes WHERE id = ?
            `);

        this._moveAndRename = this.prepare("run", `
            UPDATE nodes
            SET name = ?, parent_id = ?, mtime = ?
            WHERE id = ?
            `);
        this.moveAndRename = this.db.transaction((name: string, parentId: number, mtime: number | null, id: number) => {
            this._moveAndRename(name, parentId, mtime, id);
            if (parentId !== DriveFileSystem.ROOT_NODE_ID) {
                this.setMtime(mtime, parentId);
            }
        });

        this.setMtime = this.prepare("run", `
            UPDATE nodes
            SET mtime = ?
            WHERE id = ?
            `);

        this.setSize = this.prepare("run", `
            UPDATE nodes
            SET size = ?
            WHERE id = ?
            `);

        this.setMeta = this.prepare("run", `
            UPDATE nodes
            SET mtime = ?, size = ?
            WHERE id = ?
            `);

        this._isDescendant = this.prepare("get", `
            WITH RECURSIVE tree AS (
                SELECT id FROM nodes WHERE id = ?
                UNION ALL
                SELECT n.id
                FROM nodes n
                JOIN tree t ON n.parent_id = t.id
            )
            SELECT 1 FROM tree WHERE id = ? LIMIT 1
            `);

        this.deleteChildren = this.prepare("run", `
            DELETE FROM nodes
            WHERE id <> ?;
            `);

        this.tree = this.prepare("all", `
            WITH RECURSIVE subtree(id, name, type, parent_id) AS (
                SELECT id, name, type, parent_id
                FROM nodes
                WHERE id = ?

                UNION ALL

                SELECT n.id, n.name, n.type, n.parent_id
                FROM nodes n
                INNER JOIN subtree s ON n.parent_id = s.id
            )
            SELECT * FROM subtree
            `);
        this.insertTree = this.db.transaction((destId: number, root: VfsNode, subtree: VfsNode[], mtime: number | null) => {
            const idMap = new Map<number, number>();
            idMap.set(root.parent_id!, destId);

            this.setMtime(mtime, destId);

            const nodesByParent = new Map();
            for (const node of subtree) {
                if (!nodesByParent.has(node.parent_id)) nodesByParent.set(node.parent_id, []);
                nodesByParent.get(node.parent_id).push(node);
            }

            const sortedNodes: VfsNode[] = [root];

            function dfs(parentId: number) {
                const children = nodesByParent.get(parentId) || [];
                for (const child of children) {
                    sortedNodes.push(child);
                    dfs(child.id);
                }
            }

            dfs(root.id);

            for (const node of sortedNodes) {
                const newParentId = idMap.get(node.parent_id!)!; 
                let info: VfsNode | undefined = this.findChild(newParentId, node.name);
                if (info === undefined) {
                    if (node.type === "file") {
                        info = this.insert(node.name, node.type, newParentId, node.mtime, node.size)!;
                    } else {
                        info = this.findChild(newParentId, node.name);
                        if (!info) {
                            info = this.insert(node.name, node.type, newParentId, node.mtime, node.size)!;
                        }
                    }
                } else {
                    if (info.type !== node.type) {
                        throw new VfsError("InvalidOperation", "Cannot merge tree with destination, node type mismatch.");
                    }

                    this.setMeta(node.mtime, node.size, info.id);
                }
                idMap.set(node.id, info.id);
            }
        });

        this.resolve = this.db.transaction((path: string) => {
            let node: VfsNode | undefined = DriveFileSystem.ROOT_NODE;

            for (const part of VfsPath.walk(path)) {
                if (node.type !== "directory") throw new VfsError("TraversalError", "Cannot traverse into a file.");
                if (part === ".") continue;
                if (part === "..") {
                    if (node.id === DriveFileSystem.ROOT_NODE_ID) throw new VfsError("TraversalError", "Cannot traverse outside of root.");
                    if (!node.parent_id) throw new VfsError("TraversalError", "This node has no parent.");
                
                    const parent = this.get(node.parent_id);
                    if (!parent) throw new VfsError("TraversalError", "Could not find parent node.");
                    node = parent;
                
                    continue;
                }

                node = this.findChild(node!.id, part);
                if (!node) return undefined;
            }

            return node;
        });
    }

    public dispose() {
        this.db.close();
    }
}

export class Drive {
    readonly fs: DriveFileSystem;

    readonly name: string;
    readonly physicalPath: string;
    
    permissions: VfsPermissions; 

    constructor(name: string, vfsPath: string, physicalPath: string, permissions: VfsPermissions) {
        this.fs = new DriveFileSystem(vfsPath);

        this.name = name;
        this.physicalPath = Path.resolve(physicalPath);
        
        this.permissions = permissions;
    }

    /**
     * Converts a VFS path to a physical path
     */
    public getPhysicalPath(drivePath: string) {
        return Path.join(this.physicalPath, drivePath);
    }

    /**
     * Converts a local drive path to its global path
     */
    public toGlobalPath(drivePath: string) {
        return VfsPath.join(this.physicalPath, drivePath);
    }

    public dispose() {
        this.fs.dispose();
    }
}